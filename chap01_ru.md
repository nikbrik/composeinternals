# 1. Composable-функции

## Смысл Composable-функций

Вероятно, самый уместный способ начать книгу о внутреннем устройстве Jetpack Compose — разобраться с Composable-функциями: они являются атомарными строительными блоками Jetpack Compose и той конструкцией, с помощью которой мы пишем composable-деревья. Я намеренно говорю здесь «деревья»: composable-функции можно понимать как узлы в большом дереве, которое Compose runtime представляет в памяти. К деталям мы придём в своё время, но правильную модель полезно формировать с самого начала.

Если говорить о синтаксисе, любая обычная Kotlin-функция может стать Composable-функцией — достаточно аннотировать её как `@Composable`:

```kotlin
1 @Composable
2 fun NamePlate(name: String) {
3   // Our composable code
4 }
```

Этим мы по сути сообщаем компилятору, что функция призвана преобразовать некоторые данные в узел для регистрации в composable-дереве. То есть если читать Composable-функцию как `@Composable (Input) -> Unit`, то вход — это данные, а «выход» — не возвращаемое значение, как можно было бы подумать, а зарегистрированное действие по вставке элемента в дерево. Можно сказать, что это происходит как побочный эффект выполнения функции.

Обратите внимание: возврат `Unit` из функции, принимающей входные данные, означает, что мы так или иначе потребляем эти данные в теле функции.

Описанное действие в терминологии Compose обычно называют «emitting» (эмитирование). Composable-функции эмитируют при выполнении, и это происходит в процессе composition. Подробности этого процесса — в следующих главах. Пока же каждый раз, когда речь идёт о «composing» Composable-функции, можно мысленно заменять это на «выполнение».

![](resources/composable_function.png)
*Composable-функция эмитирует (схема)*

Единственная цель выполнения наших Composable-функций — построить или обновить представление дерева в памяти. Так оно остаётся актуальным относительно структуры, которую описывает: Composable-функции будут выполняться заново при изменении прочитанных ими данных. Для обновления дерева они могут эмитировать действия вставки новых узлов, как сказано выше, а также удалять, заменять или перемещать узлы. Composable-функции также могут читать и записывать состояние в дерево / из дерева.

## Свойства Composable-функций

Аннотирование функции как Composable имеет и другие важные следствия. Аннотация `@Composable` фактически **меняет тип** функции или выражения, к которому применена, и, как любой другой тип, накладывает на неё ограничения и свойства. Эти свойства важны для Jetpack Compose, так как раскрывают возможности библиотеки.

Compose runtime ожидает, что Composable-функции соблюдают упомянутые свойства — тогда он может опираться на определённое поведение и использовать различные оптимизации: параллельная composition, произвольный порядок composition по приоритетам, умная recomposition, позиционная мемоизация и др. Пока не стоит пугаться всех этих понятий — мы разберём каждое в нужный момент.

Вообще говоря, оптимизации на этапе выполнения возможны только тогда, когда runtime может опереться на определённые гарантии относительно кода: условия и поведение. Это позволяет выполнять (или «потреблять») этот код по разным стратегиям и техникам, использующим эти гарантии.

Пример таких гарантий — связь между элементами в коде. Зависят ли они друг от друга? Можно ли выполнять их параллельно или в другом порядке без изменения результата программы? Можно ли считать каждый атомарный фрагмент логики изолированной единицей?

Разберём свойства Composable-функций.

## Контекст вызова (calling context)

Большинство свойств Composable-функций обеспечиваются компилятором Compose. Как плагин компилятора Kotlin он выполняется на обычных фазах компиляции и имеет доступ ко всей информации, которой располагает компилятор Kotlin. Это позволяет перехватывать и преобразовывать IR (промежуточное представление) всех Composable-функций в исходниках и добавлять к ним дополнительную информацию.

Один из добавляемых элементов — новый параметр в конце списка параметров: `Composer`. Этот параметр неявный, разработчик о нём не заботится. Его экземпляр внедряется во время выполнения и передаётся во все дочерние вызовы Composable, так что он доступен на всех уровнях дерева.

![](resources/calling_context.png)
*Контекст вызова Composable (схема)*

В коде допустим, у нас есть такой Composable:

```kotlin
1 @Composable
2 fun NamePlate(name: String, lastname: String) {
3   Column(modifier = Modifier.padding(16.dp)) {
4     Text(text = name)
5     Text(text = lastname, style = MaterialTheme.typography.subtitle1)
6   }
7 }
```

Компилятор преобразует это во что-то вроде:

```kotlin
 1 fun NamePlate(name: String, lastname: String, $composer: Composer&lt;*&gt;) {
 2   ...
 3   Column(modifier = Modifier.padding(16.dp), $composer) {
 4     Text( 
 5       text = name,
 6       $composer
 7     )
 8     Text(
 9       text = lastname,
10       style = MaterialTheme.typography.subtitle1,
11       $composer
12     )
13   }
14   ...
15 }
```

Как видно, `Composer` передаётся во все вызовы Composable в теле. Кроме того, компилятор Compose накладывает строгое правило: Composable-функции можно вызывать только из других Composable-функций. Это и есть требуемый **контекст вызова**; он гарантирует, что дерево состоит только из Composable-функций и `Composer` может передаваться вниз.

`Composer` — связующее звено между Composable-кодом, который мы пишем, и Compose runtime. Composable-функции используют его, чтобы эмитировать изменения в дерево и сообщать runtime о его форме для построения или обновления представления в памяти.

## Идемпотентность

От Composable-функций ожидается идемпотентность относительно дерева узлов, которое они порождают. Повторное выполнение Composable-функции с теми же входными параметрами должно давать то же дерево. Jetpack Compose runtime опирается на это при recomposition и т.п.

В Jetpack Compose **recomposition** — это повторное выполнение Composable-функций при изменении их входных данных, чтобы они могли эмитировать обновлённую информацию и обновлять дерево. Runtime должен иметь возможность перезапускать наши Composable-функции в произвольные моменты и по разным причинам.

Процесс recomposition обходит дерево и определяет, какие узлы нужно перезапустить (выполнить заново). Перезапускаются только узлы с изменившимися входами, остальные **пропускаются**. Пропуск узла возможен только когда представляющая его Composable-функция идемпотентна: runtime может считать, что при тех же входах результат будет тем же. Этот результат уже есть в памяти, поэтому Compose не нужно выполнять функцию снова.

## Отсутствие неконтролируемых побочных эффектов

Побочный эффект — любое действие, выходящее из-под контроля функции, в которой оно вызывается, и делающее что-то неожиданное «сбоку». К побочным эффектам относят чтение из локального кэша, сетевой запрос, установку глобальной переменной. Они делают вызывающую функцию зависимой от внешних факторов: внешнего состояния, которое могут менять другие потоки, сторонних API, которые могут выбросить исключение, и т.д. Иными словами, функция не зависит только от своих входов при получении результата.

Побочные эффекты — **источник неоднозначности**. Для Compose это плохо: runtime ожидает, что Composable-функции предсказуемы (детерминированы) и их можно безопасно выполнять многократно. Если Composable-функция выполняет побочные эффекты, при каждом запуске состояние программы может быть разным, и идемпотентность теряется.

Представим, что мы выполняем сетевой запрос прямо из тела Composable-функции:

```kotlin
 1 @Composable
 2 fun EventsFeed(networkService: EventsNetworkService) {
 3   val events = networkService.loadAllEvents()
 4 
 5   LazyColumn {
 6     items(events) { event -&gt;
 7       Text(text = event.name)
 8     }
 9   }
10 }
```

Это было бы очень рискованно: функция может многократно перезапускаться за короткое время со стороны Compose runtime, из-за чего сетевой запрос будет уходить снова и снова и выйдет из-под контроля. Ещё хуже то, что эти выполнения могут происходить из разных потоков без координации.

Compose runtime оставляет за собой право выбирать стратегии выполнения наших Composable-функций. Он может переносить recomposition на другие потоки для использования нескольких ядер или выполнять их в произвольном порядке по своим приоритетам (например, Composable, не отображаемые на экране, могут получить более низкий приоритет).

Ещё один типичный подводный камень — зависимость одной Composable-функции от результата другой и неявный порядок вызовов. Такого нужно избегать. Пример:

```kotlin
1 @Composable
2 fun MainScreen() {
3   Header()
4   ProfileDetail()
5   EventList()
6 }
```

В этом фрагменте `Header`, `ProfileDetail` и `EventList` могут выполняться в любом порядке или даже параллельно. Не стоит писать логику, опирающуюся на конкретный порядок — например, читать в `ProfileDetail` внешнюю переменную, которую по замыслу записывает `Header`.

В общем случае побочные эффекты в Composable-функциях нежелательны. Нужно стремиться к тому, чтобы все Composable-функции были без состояния: все входы передаются параметрами, и они используются только для получения результата. Так Composable становятся проще, «тупее» и хорошо переиспользуемыми. Но для написания программ с состоянием побочные эффекты нужны, так что на каком-то уровне их придётся вызывать (часто в корне composable-дерева). Программам нужны сетевые запросы, сохранение в БД, кэши в памяти и т.д. Поэтому Jetpack Compose предлагает механизмы безопасного вызова эффектов из Composable-функций в контролируемой среде — **обработчики эффектов (effect handlers)**.

Обработчики эффектов привязывают побочные эффекты к жизненному циклу Composable: эффекты могут быть ограничены им или управляться им. Они позволяют автоматически отменять/останавливать эффекты при выходе Composable из дерева, перезапускать их при изменении входов эффекта или растягивать один и тот же эффект на несколько выполнений (recomposition), так что он вызывается только один раз. Обработчики эффектов мы разберём в следующих главах. Они позволяют не вызывать эффекты напрямую из тела Composable без какого-либо контроля.

## Restartable (перезапускаемость)

Мы уже упоминали это несколько раз. Composable-функции могут перезапускаться (recompose), то есть они не как обычные функции, которые вызываются один раз в рамках стека вызовов. Обычный стек вызовов выглядит так: каждая функция вызывается один раз и может вызвать одну или несколько других.

![](resources/restartable1.png)
*Обычный стек вызовов (схема)*

С другой стороны, Composable-функции могут перезапускаться (выполняться заново, recompose) многократно, и runtime хранит на них ссылки для этого. Вот как может выглядеть дерево вызовов Composable:

![](resources/restartable2.png)
*Дерево вызовов Composable с перезапуском (схема)*

Composable 4 и 5 выполняются заново после изменения их входов.

Compose выборочно решает, какие узлы дерева перезапускать, чтобы представление в памяти оставалось актуальным. Composable-функции спроектированы реактивными и перезапускаются при изменении наблюдаемого ими состояния.

Компилятор Compose находит все Composable-функции, читающие какое-либо состояние, и генерирует код, который сообщает runtime, как их перезапускать. Composable, не читающие состояние, перезапускать не нужно, поэтому нет смысла сообщать runtime, как это делать.

## Быстрое выполнение

Composable-функции и дерево Composable-функций можно рассматривать как быстрый, декларативный и лёгкий способ построить описание программы, которое сохраняется в памяти и интерпретируется / материализуется на более позднем этапе.

Composable-функции не строят и не возвращают UI. Они лишь эмитируют данные для построения или обновления структуры в памяти. Поэтому они очень быстрые, и runtime может выполнять их многократно без опасений — иногда очень часто, например на каждом кадре анимации.

Разработчики должны соответствовать этому ожиданию. Любые тяжёлые вычисления нужно выносить в корутины и оборачивать в один из привязанных к жизненному циклу обработчиков эффектов, о которых мы узнаем дальше в книге.

## Позиционная мемоизация

Позиционная мемоизация — разновидность мемоизации функций. Мемоизация функции — способность кэшировать результат по входам, чтобы не вычислять его заново при каждом вызове с теми же аргументами. Как мы уже видели, это возможно только для чистых (**детерминированных**) функций: мы уверены, что для одних и тех же входов результат всегда один и тот же, и его можно кэшировать и переиспользовать.

Мемоизация функций — широко известная техника в парадигме функционального программирования, где программы определяются как композиция чистых функций.

При мемоизации функций вызов можно идентифицировать по комбинации имени, типа и значений параметров. По этим элементам строится уникальный ключ для сохранения/индексации/чтения кэшированного результата при последующих вызовах. В Compose учитывается ещё один элемент: Composable-функции всегда «знают» **своё расположение в исходном коде**. Runtime будет генерировать разные id (уникальные в рамках родителя), когда одна и та же функция вызывается с теми же параметрами из разных мест:

```kotlin
1 @Composable
2 fun MyComposable() {
3   Text(&quot;Hello&quot;) // id 1
4   Text(&quot;Hello&quot;) // id 2
5   Text(&quot;Hello&quot;) // id 3
6 }
```

В памяти будет храниться три разных экземпляра, каждый со своей идентичностью.

![](resources/positional_memoization.png)
*Позиционная мемоизация (схема)*

Идентичность Composable сохраняется между recomposition, так что runtime может обращаться к этой структуре, чтобы понять, вызывался ли Composable ранее, и при возможности пропустить его.

Иногда присвоить уникальные идентичности сложно. Один из примеров — списки Composable, порождённые циклом:

```kotlin
1 @Composable
2 fun TalksScreen(talks: List&lt;Talk&gt;) {
3   Column {
4     for (talk in talks) {
5       Talk(talk)
6     }
7   }
8 }
```

Здесь `Talk(talk)` каждый раз вызывается из одной и той же позиции, но каждый talk — другой элемент списка и значит другой узел в дереве. В таких случаях Compose runtime опирается на **порядок вызовов** для генерации уникального id и различения элементов. Это хорошо работает при добавлении элемента в конец списка — остальные вызовы остаются на тех же позициях. Но если добавлять элементы в начало или в середину? Тогда runtime перезапустит все `Talk` ниже точки вставки, так как их позиции сдвинулись, даже если их входы не изменились. Это неэффективно (особенно для длинных списков), ведь эти вызовы можно было бы пропустить.

Чтобы решить эту проблему, Compose предоставляет Composable `key` для явного присвоения ключа вызову:

```kotlin
 1 @Composable
 2 fun TalksScreen(talks: List&lt;Talk&gt;) {
 3   Column {
 4     for (talk in talks) {
 5       key(talk.id) { // Unique key
 6         Talk(talk)
 7       }
 8     }
 9   }
10 }
```

В этом примере мы используем id доклада (предположительно уникальный) как ключ для каждого `Talk` — это позволит runtime сохранять идентичность всех элементов списка **независимо от позиции**.

Позиционная мемоизация позволяет runtime по замыслу «запоминать» Composable-функции. Любая Composable-функция, которую компилятор Compose считает restartable, должна также быть skippable и тем самым **автоматически запоминаемой**. Compose построен на этом механизме.

Иногда разработчикам нужен доступ к этой структуре в памяти на уровне более мелком, чем scope одной Composable-функции. Например, нужно закэшировать результат тяжёлого вычисления внутри Composable. Для этого Compose runtime предоставляет функцию `remember`:

```kotlin
 1 @Composable
 2 fun FilteredImage(path: String) {
 3   val filters = remember { computeFilters(path) }
 4   ImageWithFiltersApplied(filters)
 5 }
 6 
 7 @Composable
 8 fun ImageWithFiltersApplied(filters: List&lt;Filter&gt;) {
 9   TODO()
10 }
```

Здесь мы используем `remember`, чтобы закэшировать результат предвычисления фильтров изображения. Ключ для индексации кэшированного значения строится по позиции вызова в исходниках и по входу функции (в данном случае путь к файлу). Функция `remember` — это просто Composable-функция, которая умеет читать и писать в структуру в памяти, хранящую состояние дерева. Она лишь выставляет механизм «позиционной мемоизации» разработчику.

В Compose мемоизация не распространяется на всё приложение. Когда что-то мемоизируется, это делается в контексте вызывающего это Composable. В примере выше это `FilteredImage`. На практике Compose обращается к структуре в памяти и ищет значение в диапазоне слотов, где хранится информация об охватывающем Composable. Получается что-то вроде **одиночки в рамках этого scope**. Если тот же Composable вызывался бы из другого родителя, вернулся бы новый экземпляр значения.

## Сходство с suspend-функциями

Kotlin-функции с `suspend` можно вызывать только из других `suspend`-функций, то есть им тоже нужен контекст вызова. Это гарантирует, что `suspend`-функции можно объединять в цепочки и даёт компилятору Kotlin возможность внедрять и передавать среду выполнения по всем уровням вычислений. Эта среда добавляется к каждой `suspend`-функции как дополнительный параметр в конце списка — `Continuation`. Параметр тоже неявный, так что разработчик может о нём не думать. `Continuation` используется для включения новых возможностей языка.

Звучит знакомо?

В системе корутин Kotlin `Continuation` подобен колбэку: он указывает программе, как продолжить выполнение.

Пример. Код вида:

```kotlin
1 suspend fun publishTweet(tweet: Tweet): Post = ...
```

компилятор Kotlin заменяет на:

```kotlin
1 fun publishTweet(tweet: Tweet, callback: Continuation&lt;Post&gt;): Unit
```

`Continuation` несёт всю информацию, которая нужна runtime Kotlin для приостановки и возобновления выполнения в точках suspension в программе. Так `suspend` — ещё один хороший пример того, как требование контекста вызова может служить способом передачи неявной информации по дереву выполнения — информации, которую runtime может использовать для продвинутых возможностей языка.

Аналогично можно воспринимать `@Composable` как возможность языка: она делает обычные Kotlin-функции перезапускаемыми, реактивными и т.д.

Резонный вопрос: почему команда Jetpack Compose не использовала `suspend` для нужного поведения? Хотя оба механизма реализуют похожий паттерн, они дают совершенно разные возможности. Интерфейс `Continuation` жёстко завязан на приостановку и возобновление выполнения и смоделирован как интерфейс колбэка; Kotlin генерирует для него реализацию со всей необходимой логикой для переходов, координации точек suspension, обмена данными и т.д. Сценарий Compose другой: цель — создать представление в памяти большого графа вызовов, который можно по-разному оптимизировать во время выполнения.

Поняв сходство Composable и `suspend`-функций, полезно вспомнить идею «раскраски функций».

## «Цвет» Composable-функций

У Composable-функций другие ограничения и возможности, чем у обычных функций. У них другой тип (об этом позже), и они моделируют свою специфическую задачу. Эту дифференциацию можно понимать как «раскраску функций» — они образуют отдельную **категорию функций**.

«Раскраска функций» — концепция, которую объяснил Боб Нистром из команды Dart в Google в посте [«What color is your function?»](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/) (2015). Он описал, как async- и sync-функции плохо комбинируются: нельзя вызвать async-функцию из sync без того, чтобы сделать вызывающую тоже async или предоставить механизм ожидания (await). Поэтому в языках и библиотеках появились Promises и `async/await` — попытка вернуть композируемость. Боб называет эти две категории разными «цветами» функций.

В Kotlin ту же задачу решает `suspend`. Но `suspend`-функции тоже «окрашены»: вызывать их можно только из других `suspend`-функций. Комбинировать программу из обычных и `suspend`-функций можно только через точки интеграции (запуск корутин). Интеграция для разработчика не прозрачна.

В целом такое ограничение ожидаемо. Мы моделируем две категории функций, представляющие концепции разной природы — как два разных языка: операции с немедленным результатом (sync) и операции, разворачивающиеся во времени и в итоге дающие результат (async), зачастую с задержкой.

В Jetpack Compose случай Composable-функций аналогичен. Вызывать Composable-функции из обычных функций напрямую нельзя. Для этого нужна точка интеграции (например, `Composition.setContent`). У Composable-функций цель совсем не та, что у обычных: они предназначены не для программной логики, а для описания изменений дерева узлов.

Может показаться, что я немного лукавлю. Одно из преимуществ Composable-функций — возможность описывать UI с помощью логики, то есть иногда нужно вызывать Composable из обычных функций. Например:

```kotlin
1 @Composable
2 fun SpeakerList(speakers: List&lt;Speaker&gt;) {
3   Column {
4     speakers.forEach {
5       Speaker(it)
6     }
7   }
8 }
```

Composable `Speaker` вызывается из лямбды `forEach`, и компилятор не ругается. Как тогда возможно смешивать «цвета» функций?

Причина — `inline`. Операторы коллекций объявлены как `inline`, поэтому их лямбды подставляются в вызывающий код, и по сути дополнительного уровня косвенности нет. В примере выше вызов Composable `Speaker` оказывается встроенным в тело `SpeakerList`, и это допустимо, так как оба — Composable-функции. Используя `inline`, мы обходим проблему раскраски и можем писать логику внутри Composable. Дерево по-прежнему будет состоять только из Composable-функций.

Но действительно ли раскраска — проблема?

Она могла бы быть проблемой, если бы приходилось постоянно переключаться между двумя типами функций. Но для `suspend` и `@Composable` это не так. Оба механизма требуют точки интеграции, и за ней получается полностью «окрашенный» стек вызовов (всё либо `suspend`, либо Composable). Это скорее преимущество: компилятор и runtime могут по-разному обрабатывать окрашенные функции и включать продвинутые возможности языка, недоступные для обычных функций.

В Kotlin `suspend` позволяет идиоматично и выразительно описывать асинхронные неблокирующие программы; язык получает способ представить сложную концепцию очень просто — модификатором `suspend` у функций. С другой стороны, `@Composable` делает обычные функции перезапускаемыми, пропускаемыми и реактивными — возможностями, которых у обычных Kotlin-функций нет.

## Типы Composable-функций

Аннотация `@Composable` на этапе компиляции фактически меняет тип функции. С точки зрения синтаксиса тип Composable-функции — `@Composable (T) -> A`, где `A` может быть `Unit` или любым другим типом, если функция возвращает значение (например, `remember`). Разработчики могут использовать этот тип для объявления Composable-лямбд так же, как обычных лямбд в Kotlin.

```kotlin
 1 // This can be reused from any Composable tree
 2 val textComposable: @Composable (String) -&gt; Unit = {
 3   Text(
 4     text = it,
 5     style = MaterialTheme.typography.subtitle1
 6   )
 7 }
 8 
 9 @Composable
10 fun NamePlate(name: String, lastname: String) {
11   Column(modifier = Modifier.padding(16.dp)) {
12     Text(
13       text = name,
14       style = MaterialTheme.typography.h6
15     )
16     textComposable(lastname)
17   }
18 }
```

У Composable-функций может быть и тип `@Composable Scope.() -> A`, часто используемый для ограничения информации scope’ом конкретного Composable:

```kotlin
 1 inline fun Box(
 2   ...,
 3   content: @Composable BoxScope.() -&gt; Unit
 4 ) {
 5   // ...
 6   Layout(
 7     content = { BoxScopeInstance.content() },
 8     measurePolicy = measurePolicy,
 9     modifier = modifier
10   )
11 }
```

С точки зрения языка типы нужны, чтобы давать компилятору информацию для статической проверки, иногда генерировать удобный код и ограничивать/уточнять использование данных во время выполнения. Аннотация `@Composable` меняет то, как функция проверяется и используется в runtime, поэтому считается, что у неё другой тип, чем у обычной функции.
