# 2. Компилятор Compose

Jetpack Compose состоит из набора библиотек, но в этой книге основное внимание уделяется трём: компилятору Compose, рантайму Compose и Compose UI.

Компилятор Compose и рантайм — основа Jetpack Compose. Compose UI технически не входит в архитектуру Compose: рантайм и компилятор спроектированы универсально и могут использоваться любыми клиентскими библиотеками, соблюдающими их требования. Compose UI — лишь один из доступных клиентов. Есть и другие клиентские библиотеки в разработке, например для десктопа и веба от JetBrains. Тем не менее разбор Compose UI поможет понять, как Compose наполняет in-memory представление composable-дерева в рантайме и как в итоге материализует из него реальные элементы.

![](resources/compose_architecture.png)
*Архитектура Compose*

При первом знакомстве с Compose может возникнуть путаница с точным порядком вещей. До этого момента в книге мы слышали, что компилятор и рантайм работают вместе и раскрывают возможности библиотеки, но без предварительного опыта это остаётся довольно абстрактным. Было бы полезно глубже разобраться: какие действия выполняет компилятор Compose, чтобы код соответствовал требованиям рантайма, как работает рантайм, когда запускаются первичная composition и последующие recomposition, как формируется in-memory представление дерева и как эта информация используется для дальнейших recomposition. Понимание этого даёт общую картину работы библиотеки и ожиданий от неё при написании кода.

Приступим — начнём с компилятора.

## Плагин компилятора Kotlin

Jetpack Compose частично опирается на генерацию кода. В мире Kotlin и JVM для этого обычно используют процессоры аннотаций через **kapt**, но Jetpack Compose устроен иначе: компилятор Compose — это плагин компилятора Kotlin. Это позволяет встроить работу на этапе компиляции в фазы компиляции Kotlin, получать более полную информацию о структуре кода и ускорять процесс в целом. kapt запускается до компиляции, а плагин компилятора **встраивается в процесс компиляции**.

Плагин компилятора Kotlin также даёт возможность сообщать диагностику на фронтенд-фазе компилятора, обеспечивая быструю обратную связь. Однако эта диагностика не показывается в IDE, так как IDEA не интегрирована с плагином напрямую. Все инспекции уровня IDEA в Compose добавлены отдельным плагином IDEA, не разделяющим код с плагином компилятора Compose. Диагностика фронтенда выдаётся сразу при нажатии кнопки компиляции. Ускорение обратной связи — главная польза статического анализа на фронтенд-фазе компилятора Kotlin, и компилятор Jetpack Compose этим активно пользуется.

Ещё одно важное преимущество плагинов компилятора Kotlin — они могут по своему усмотрению изменять существующие исходники (не только добавлять новый код, как процессоры аннотаций). Они способны модифицировать выходной IR для этих элементов до его понижения до более атомарных конструкций, которые затем переводятся в примитивы целевых платформ — помним, Kotlin мультиплатформенный. В этой главе мы углубимся в детали; в итоге компилятор Compose получает возможность **трансформировать Composable-функции** так, как того требует рантайм.

У плагинов компилятора Kotlin большое будущее. Многие известные процессоры аннотаций, вероятно, постепенно переедут в плагины компилятора или «лёгкие» плагины через KSP (Kotlin Symbol Processing). См. блок ниже.

Если вам интересны плагины компилятора Kotlin, рекомендую ознакомиться с [KSP (Kotlin Symbol Processing)](https://github.com/google/ksp) — библиотекой, которую Google предлагает как замену Kapt. KSP предлагает нормализованный DSL для «написания лёгких плагинов компилятора», на который могут опираться библиотеки для метапрограммирования. Обязательно прочитайте [раздел «Why KSP»](https://github.com/google/ksp/blob/main/docs/why-ksp.md) в репозитории KSP.

Также учтите: компилятор Jetpack Compose сильно опирается на трансформации IR, и их массовое использование в метапрограммировании может быть рискованным. Если бы все процессоры аннотаций стали плагинами компилятора, трансформаций IR могло бы стать слишком много и это могло бы дестабилизировать язык. Изменение и расширение языка всегда несёт риск. Поэтому в общем случае KSP — более предпочтительный выбор.

## Аннотации Compose

Вернёмся к порядку вещей. Сначала нужно понять, как мы аннотируем код, чтобы компилятор мог находить нужные элементы и делать свою работу. Начнём с доступных аннотаций Compose.

Даже если плагины компилятора умеют больше, чем процессоры аннотаций, у них есть общее. Один пример — фронтенд-фаза, часто используемая для статического анализа и проверок.

Компилятор Compose использует хуки/точки расширения во фронтенде компилятора Kotlin, чтобы проверять соблюдение накладываемых ограничений и то, что система типов правильно отличает функции, объявления и выражения с `@Composable` от не-Composable. Помимо этого Compose предоставляет дополнительные аннотации для дополнительных проверок и разных оптимизаций или «укорочений» в рантайме в определённых случаях. Все аннотации поставляются библиотекой Compose runtime.

Разберём самые важные аннотации.

Все аннотации Jetpack Compose предоставляются Compose runtime, так как и компилятор, и рантайм активно их используют.

### @Composable

Эта аннотация уже подробно разобрана в главе 1. Тем не менее ей нужен отдельный подраздел — она явно главная. Поэтому она первая в списке.

Главное отличие компилятора Compose от процессора аннотаций в том, что Compose фактически **изменяет** объявление или выражение, к которому применена аннотация. Большинство процессоров аннотаций так не умеют — они создают дополнительные или соседние объявления. Поэтому компилятор Compose использует трансформации IR. Аннотация `@Composable` действительно **меняет тип** элемента, а плагин компилятора обеспечивает соблюдение правил во фронтенде, чтобы типы с Composable не обрабатывались так же, как их не-Composable аналоги.

Изменение типа объявления или выражения через `@Composable` даёт ему «память»: возможность вызывать `remember` и использовать Composer/slot table. Также появляется жизненный цикл, с которым могут согласовываться эффекты, запускаемые в теле (например, продолжение job через recomposition). Composable-функции получают идентичность, которую сохраняют, и позицию в результирующем дереве — то есть могут эмитировать узлы в Composition и обращаться к `CompositionLocal`.

Кратко: Composable-функция — это отображение данных в узел, который эмитируется в дерево при выполнении. Узел может быть UI-узлом или узлом любой другой природы в зависимости от библиотеки, потребляющей Compose runtime. Jetpack Compose runtime работает с **обобщёнными типами узлов**, не привязанными к конкретному сценарию или семантике. Эту тему мы подробно разберём ближе к концу книги.

### @ComposeCompilerApi

Этой аннотацией Compose помечает части API, предназначенные только для компилятора — чтобы сообщить об этом пользователям и предупредить о необходимости осторожного использования.

### @InternalComposeApi

Некоторые API помечены в Compose как внутренние, так как они могут меняться внутри, даже если публичная поверхность API остаётся неизменной и замороженной к стабильному релизу. У этой аннотации шире область, чем у ключевого слова `internal` в языке: она допускает использование между модулями, чего в Kotlin нет.

### @DisallowComposableCalls

Используется, чтобы запретить вызовы Composable внутри функции. Полезно для параметров-лямбд с `inline` у Composable-функций, внутри которых нельзя безопасно вызывать Composable. Лучше всего подходит для лямбд, которые **не** вызываются при каждой recomposition.

Пример — функция `remember` из Compose runtime. Эта Composable-функция запоминает значение, вычисленное блоком `calculation`. Блок вычисляется только при первичной composition, при дальнейших recomposition всегда возвращается уже вычисленное значение.

```kotlin
1 @Composable
2 inline fun &lt;T&gt; remember(calculation: @DisallowComposableCalls () -&gt; T): T =
3   currentComposer.cache(false, calculation)
```
*Composables.kt*

Благодаря этой аннотации вызовы Composable внутри лямбды `calculation` запрещены. Иначе при вызове они занимали бы место в slot table (эмитируя), а после первой composition эта область освобождалась бы, так как лямбда больше не вызывается.

Аннотацию лучше использовать для inline-лямбд, вызываемых условно как деталь реализации и не призванных быть «живыми», как composable. Это нужно потому, что inline-лямбды особенные: они «наследуют» способности Composable от контекста вызова. Например, лямбда вызова `forEach` не помечена как `@Composable`, но внутри неё можно вызывать Composable-функции, если сам `forEach` вызывается из Composable-функции. Для `forEach` и многих других inline API это желательно, но **не** желательно в случаях вроде `remember` — здесь и нужна эта аннотация.

Аннотация «заразная»: если вы вызываете inline-лямбду внутри inline-лямбды с `@DisallowComposableCalls`, компилятор потребует пометить и эту лямбду как `@DisallowComposableCalls`.

Как можно догадаться, в клиентских проектах эту аннотацию, скорее всего, использовать не придётся; она может пригодиться, если вы используете Jetpack Compose не для Compose UI и пишете свою клиентскую библиотеку для рантайма с соблюдением его ограничений.

### @ReadOnlyComposable

В применении к Composable-функции означает: мы знаем, что тело этого Composable никогда не будет писать в composition, только читать. То же должно быть верно для всех вложенных вызовов Composable в теле. Это позволяет рантайму не генерировать код, который не понадобится, если Composable действительно соблюдает это условие.

Для любого Composable, который пишет в composition, компилятор генерирует «группу», оборачивающую его тело, и в рантайме эмитируется вся группа. Эти группы несут информацию о Composable в composition: как очистить записанные данные при замене при recomposition другим Composable или как перемещать данные, сохраняя идентичность Composable. Генерируются разные типы групп: restartable, movable и т.д.

Чтобы понять, что такое «группа», представьте пару указателей на начало и конец выделенного фрагмента текста. У всех групп есть ключ позиции в исходниках для хранения группы — он и обеспечивает позиционную мемоизацию. По нему же различаются идентичности веток `if` и `else` в условной логике:

```kotlin
1 if (condition) {
2   Text(&quot;Hello&quot;)
3 } else {
4   Text(&quot;World&quot;)
5 }
```
*ConditionalTexts.kt*

Оба вызова — `Text`, но у них разная идентичность, так как для вызывающего кода это разные сущности. У movable-групп есть ещё семантический ключ идентичности для переупорядочивания внутри родительской группы.

Когда наш Composable не пишет в composition, генерация таких групп не даёт пользы — его данные не будут заменяться или перемещаться. Эта аннотация помогает этого избежать.

Примеры read-only Composable в библиотеках Compose: многие значения по умолчанию и утилиты для `CompositionLocal` (например, Material `Colors`, `Typography`), функция `isSystemInDarkTheme()`, `LocalContext`, вызовы для получения `resources` приложения любого типа (они опираются на `LocalContext`), `LocalConfiguration`. В общем, это вещи, которые задаются один раз при запуске программы и остаются неизменными и доступными для чтения из Composable в дереве.

### @NonRestartableComposable

В применении к функции или геттеру свойства делает её не перезапускаемым (non-restartable) Composable. (Не все Composable по умолчанию restartable: inline Composable или Composable с типом возврата не-`Unit` таковыми не являются.)

При добавлении аннотации компилятор не генерирует шаблонный код, позволяющий функции перезапускаться при recomposition или пропускаться. Использовать её нужно очень сдержанно: только для очень маленьких функций, которые, скорее всего, перезапускаются (restart) вызывающим их Composable, так как содержат мало логики и самостоятельная инвалидация для них не имеет смысла. Их инвалидация/recomposition по сути управляется родительским/охватывающим Composable.

Эта аннотация редко или никогда не нужна для «корректности», но может служить лёгкой оптимизацией производительности, если известно, что такое поведение даст выигрыш — иногда так и есть.

### @StableMarker

Compose runtime также предоставляет аннотации для обозначения стабильности типа: мета-аннотацию `@StableMarker` и аннотации `@Immutable` и `@Stable`. Начнём с `@StableMarker`.

`@StableMarker` — мета-аннотация, которой аннотируют другие аннотации, например `@Immutable` и `@Stable`. Звучит избыточно, но цель — переиспользование: её следствия распространяются на все аннотации, помеченные ею.

`@StableMarker` подразумевает следующие требования к стабильности данных для помеченного типа:

- Результат вызовов `equals` для одних и тех же двух экземпляров всегда одинаков.
- Composition всегда уведомляется при изменении публичного свойства помеченного типа.
- Все публичные свойства помеченного типа тоже стабильны.

Типы, помеченные `@Immutable` или `@Stable`, должны удовлетворять этим требованиям, так как обе аннотации помечены как `@StableMarker`, то есть как маркеры стабильности.

Это обещания компилятору для допущений при обработке исходников; **на этапе компиляции они не проверяются**. Решать, когда все требования выполнены, остаётся разработчику.

Компилятор Compose по возможности выводит стабильность типов и обрабатывает их как стабильные без явной аннотации. Во многих случаях это предпочтительно и гарантированно корректно. Явная аннотация важна в двух случаях:

- Когда это контракт/ожидание интерфейса или абстрактного класса: аннотация становится не только обещанием компилятору, но и **требованием** к реализации (к сожалению, никак не проверяемым).
- Когда реализация мутабельна, но мутабельность безопасна в рамках допущений стабильности. Типичный пример — тип мутабелен из-за внутреннего кэша, но публичный API типа не зависит от состояния кэша.

Вывод стабильности классов подробнее разбирается ниже в этой главе.

### @Immutable

Применяется к классу как строгое обещание компилятору: все публично доступные свойства и поля класса не изменяются после создания. Это **более сильное** обещание, чем ключевое слово `val`: `val` лишь запрещает переназначение через сеттер, но свойство может ссылаться на мутабельную структуру, так что данные остаются мутабельными при одних только `val`. Это нарушило бы ожидания Compose runtime. Иными словами, аннотация нужна Compose потому, что в Kotlin нет механизма (ключевого слова и т.п.) гарантии неизменности структуры данных.

Исходя из допущения, что значения, читаемые из типа, после инициализации не меняются, рантайм может применять оптимизации к умной recomposition и пропуску recomposition.

Хороший пример класса, который можно безопасно пометить `@Immutable`, — `data class` только с `val`-свойствами, без кастомных геттеров (иначе значение вычислялось бы при каждом вызове и могло бы отличаться, делая API нестабильным для чтения), причём все свойства — примитивы или типы, тоже помеченные `@Immutable`.

`@Immutable` также является `@StableMarker`, поэтому наследует все его следствия. Неизменяемый тип всегда удовлетворяет требованиям `@StableMarker`, так как его публичные значения не меняются. Аннотация `@Immutable` существует, чтобы помечать неизменяемые типы как стабильные.

Дополнение: неизменяемым типам не нужно уведомлять composition об изменении значений (одно из требований `@StableMarker`), потому что значения не меняются — ограничение и так выполняется.

### @Stable

Эта аннотация — более мягкое обещание, чем `@Immutable`. Её смысл зависит от элемента языка, к которому она применена.

При применении к типу означает, что тип **мутабелен** (иначе использовали бы `@Immutable`) и подчиняется только следствиям `@StableMarker`. При необходимости перечитайте их.

Когда `@Stable` применена к функции или свойству, она сообщает компилятору, что функция всегда возвращает один и тот же результат для одних и тех же входов (чистая). Это возможно только когда параметры функции тоже `@Stable`, `@Immutable` или примитивы (они считаются стабильными).

В документации есть наглядный пример важности для рантайма: *Когда все типы, передаваемые параметрами в Composable-функцию, помечены как стабильные, значения параметров сравниваются на равенство по позиционной мемоизации и вызов пропускается, если все значения равны предыдущему вызову.*

Пример типа, который можно пометить `@Stable`, — объект, чьи публичные свойства не меняются, но который нельзя считать неизменяемым (например, есть приватное мутабельное состояние или делегирование свойства в MutableState, но снаружи он используется как неизменяемый).

Следствия этой аннотации компилятор и рантайм используют для допущений об эволюции (или отсутствии эволюции) данных и для сокращений там, где нужно. Аннотацию не стоит использовать, пока вы не уверены, что её условия выполнены. Иначе мы даём компилятору неверную информацию, что легко приведёт к ошибкам в рантайме. Поэтому все эти аннотации рекомендуется применять сдержанно.

Интересно: хотя `@Immutable` и `@Stable` — разные обещания с разным смыслом, компилятор Jetpack Compose **сейчас обрабатывает их одинаково** — для включения и оптимизации умной recomposition и пропуска recomposition. Обе аннотации существуют, чтобы в будущем при необходимости можно было разделить семантику для компилятора и рантайма.

## Регистрация расширений компилятора

Раз мы познакомились с основными аннотациями **от рантайма**, пора понять, как работает плагин компилятора Compose и как он их использует.

Первое, что делает плагин, — регистрируется в пайплайне компилятора Kotlin через `ComponentRegistrar` (механизм компилятора Kotlin для этого). `ComposeComponentRegistrar` регистрирует ряд расширений компилятора для разных целей. Эти расширения обеспечивают удобство использования библиотеки и генерацию кода для рантайма. Все зарегистрированные расширения выполняются вместе с компилятором Kotlin.

Компилятор Compose также регистрирует расширения в зависимости от включённых флагов. Разработчики Jetpack Compose могут включать флаги для live literals, добавления информации об исходниках в сгенерированный код (для инспекции composition в Android Studio и других инструментах), оптимизаций для функций remember, подавления проверок совместимости версий Kotlin и/или генерации decoy-методов при трансформации IR.

Чтобы глубже разобраться в регистрации расширений плагином или в других деталях, можно смотреть исходники на [cs.android.com](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/compiler/compiler-hosted/src/main/java/androidx/compose/compiler/plugins/kotlin/ComposePlugin.kt).

## Версия компилятора Kotlin

Компилятор Compose требует строго определённую версию Kotlin и проверяет её совпадение. Это первая проверка, так как при несовпадении компиляция блокируется.

Проверку можно отключить аргументом компилятора `suppressKotlinVersionCompatibilityCheck`, но на свой риск: тогда Compose можно запускать с любой версией Kotlin, что легко приведёт к несовместимостям, особенно с учётом эволюции бэкендов компилятора Kotlin. Параметр, вероятно, добавлен для запуска и тестирования Compose на экспериментальных сборках Kotlin.

## Статический анализ

Как и у типичного плагина компилятора, первым идёт **проверка** (linting). Статический анализ выполняется сканированием исходников в поисках аннотаций библиотеки и важных проверок корректности использования — в том смысле, как ожидает рантайм. Предупреждения и ошибки выдаются через context trace, к которому имеют доступ плагины компилятора. Это хорошо стыкуется с **IDEA**, которая умеет показывать их прямо в коде при наборе. Как упоминалось, все проверки выполняются на фронтенд-фазе компилятора, что даёт максимально быструю обратную связь.

Разберём некоторые из главных статических проверок.

## Статические проверяющие (Static Checkers)

Часть зарегистрированных расширений — статические проверяющие, направляющие разработчика при написании кода. Compose регистрирует проверяющие вызовов, типов и объявлений. Они обеспечивают корректное использование библиотеки и ориентированы на решаемые ею задачи. Здесь проверяются требования к Composable-функциям из главы 1, при нарушении выдаются сообщения.

В компиляторах Kotlin есть разные анализаторы в зависимости от проверяемого элемента: инстанциация классов, типы, вызовы функций, устаревшие вызовы, контракты, захват в замыкании, инфиксные вызовы, вызовы корутин, операторные вызовы и др. — плагины могут анализировать соответствующие элементы исходников и сообщать информацию, предупреждения или ошибки.

Так как все проверяющие выполняются на фронтенд-фазе, они должны быть быстрыми и не содержать тяжёлых операций. Это ответственность разработчика плагина — проверки запускаются при наборе кода, и важно не создавать подвисаний.

## Проверки вызовов

Один из видов проверяющих Compose — проверки вызовов. Компилятор Compose выполняет статические проверки вызовов Composable-функций в разных контекстах, например внутри scope с `@DisallowComposableCalls` или `@ReadOnlyComposable`.

Проверяющий вызовов — расширение компилятора для статического анализа всех вызовов в коде. У него есть функция `check`, рекурсивно вызываемая для обхода всех PSI-элементов, считающихся вызовами (всех узлов дерева PSI). Это реализация паттерна посетителя.

Некоторым проверкам нужен контекст шире текущего элемента: например, откуда вызывается Composable. Одного узла PSI недостаточно. Для сбора информации при обходе накапливаются мелкие фрагменты в **trace** контекста, как «хлебные крошки», чтобы затем выполнять более сложные проверки. Компилятор записывает эту информацию в контекстный **trace**, расширяя область проверок и позволяя искать охватывающие лямбды, блоки try/catch и т.п.

Пример вызова в компиляторе, записывающего информацию в trace и сообщающего об ошибке при вызове Composable в контексте с `@DisallowComposableCalls`:

```kotlin
 1 if (arg?.type?.hasDisallowComposableCallsAnnotation() == true) {
 2   context.trace.record(
 3     ComposeWritableSlices.LAMBDA_CAPABLE_OF_COMPOSER_CAPTURE,
 4     descriptor, // reference to the function literal
 5     false
 6   )
 7   context.trace.report(
 8     ComposeErrors.CAPTURED_COMPOSABLE_INVOCATION.on(
 9       reportOn,
10       arg,
11       arg.containingDeclaration
12     )
13   )
14   return
15 }
```
*ContextTraceExamples.kt*

Контекст и context trace доступны при каждом вызове `check`; через тот же trace можно сообщать об ошибках, предупреждениях и информационных сообщениях. Trace можно представлять как мутабельную структуру, которую заполняют информацией для использования по ходу анализа.

Другие проверки проще и используют только данные текущего элемента; они выполняют действие и возвращают управление. При каждом вызове `check` плагин сопоставляет тип текущего узла и в зависимости от него выполняет проверку и возврат (если всё верно), сообщает об ошибке, записывает данные в trace или рекурсивно переходит к родителю. По пути выполняются разные проверки для разных аннотаций.

Компилятор Compose проверяет, что Composable не вызываются из запрещённых мест: из блока `try/catch` (не поддерживается), из функции без аннотации Composable или из лямбд с `@DisallowComposableCalls`. (Та аннотация как раз запрещала вызовы Composable внутри inline-лямбд.)

Для каждого вызова Composable компилятор поднимается по дереву PSI, проверяя вызывающих и их вызывающих, и убеждается, что все требования для этого вызова выполнены. Учитываются все сценарии: родители могут быть лямбдами, функциями, свойствами, аксессорами, блоками try/catch, классами, файлами и т.д.

PSI моделирует структуру языка для фронтенд-фаз компилятора, поэтому понимание кода полностью синтаксическое и статическое.

Важно учитывать `inline`-функции: вызов Composable из inline-лямбды допустим **только если вызывающие эту лямбду тоже Composable**. Компилятор проверяет, что любая inline-лямбда, вызывающая Composable, на каком-то уровне вверх по стеку вызовов охвачена Composable-функцией.

Ещё одна проверка вызовов — обнаружение потенциально пропущенных аннотаций `@Composable` там, где они нужны (например, если Composable вызывается внутри лямбды, компилятор может предложить добавить аннотацию к лямбде). Статический анализ не только запрещает — он может подсказать, что нужно, или как улучшить код.

Есть проверки для Composable-функций с `@ReadOnlyComposable`: они могут вызывать только другие read-only Composable, иначе нарушается контракт оптимизации (read-only Composable только читает из composition, никогда не пишет). Так как это должно выполняться на всех уровнях вложенности, паттерн посетителя здесь уместен.

Ещё одна проверка — запрет использования ссылок на Composable-функции, так как Jetpack Compose это пока не поддерживает.

## Проверки типов

Иногда мы аннотируем как Composable не только функции, но и типы. Для этого у компилятора Compose есть проверка, связанная с выводом типов: он сообщает, когда ожидался тип с `@Composable`, а найден тип без аннотации. Аналогично проверке вызовов выше. В сообщении выводятся ожидаемый и выведенный типы с аннотациями для наглядности.

## Проверки объявлений

Проверок мест вызова и типов недостаточно — нужны и проверки мест объявления. Нужно анализировать свойства, аксессоры свойств, объявления функций и параметры функций.

Свойства, геттеры и функции могут переопределяться, в том числе с аннотацией Composable. Компилятор Compose проверяет, что любые переопределения таких элементов тоже помечены как Composable, для согласованности.

Ещё одна проверка объявлений — Composable-функции не должны быть `suspend`, это не поддерживается. Как в главе 1, у `suspend` иной смысл, чем у `@Composable`; оба можно считать примитивами языка, но они представляют разные вещи и пока не поддерживаются вместе.

Объявлениями также запрещаются Composable-функция `main` и backing field у Composable-свойств.

## Подавление диагностики

Плагины компилятора могут регистрировать подавители диагностики, чтобы в определённых случаях глушить сообщения (например, ошибки статических проверок). Так бывает, когда плагины генерируют или поддерживают код, который компилятор Kotlin обычно не принял бы — подавитель обходит соответствующие проверки.

Compose регистрирует `ComposeDiagnosticSuppressor` для обхода некоторых ограничений языка, иначе блокирующих компиляцию, чтобы разрешить отдельные сценарии.

Одно из ограничений — inline-лямбды с «не-исходными» аннотациями в местах вызова (аннотации с retention `BINARY` или `RUNTIME`). Такие аннотации сохраняются в бинарниках, в отличие от `SOURCE`. Inline-лямбды на этапе компиляции подставляются в вызывающий код и нигде не хранятся, так что аннотировать уже нечего. Поэтому Kotlin запрещает это и выдаёт:

*«The lambda expression here is an inlined argument so this annotation cannot be stored anywhere.»*

Пример кода на чистом Kotlin, который вызовет эту ошибку:

```kotlin
1 @Target(AnnotationTarget.FUNCTION)
2 annotation class FunAnn
3 
4 inline fun myFun(a: Int, f: (Int) -&gt; String): String = f(a)
5 
6 fun main() {
7   myFun(1) @FunAnn { it.toString() } // Call site annotation
8 }
```
*AnnotatedInlineLambda.kt*

Компилятор Compose подавляет эту проверку только для аннотации `@Composable`, так что допустим такой код:

```kotlin
 1 @Composable
 2 inline fun MyComposable(@StringRes nameResId: Int, resolver: (Int) -&gt; String) {
 3   val name = resolver(nameResId)
 4   Text(name)
 5 }
 6 
 7 @Composable
 8 fun Screen() {
 9   MyComposable(nameResId = R.string.app_name) @Composable {
10     LocalContext.current.resources.getString(it)
11   }
12 }
```
*AnnotatedComposableInlineLambda.kt*

Это позволяет аннотировать параметры-лямбды как `@Composable` в месте вызова, а не только в объявлении функции, делая контракт функции гибче.

Ещё одно обходимое ограничение — именованные аргументы в местах, где компилятор Kotlin их не допускает, но только если функция помечена как `@Composable`.

Например, типы функций: в Kotlin у них нельзя использовать именованные аргументы, но Compose разрешает это для Composable-функций:

```kotlin
 1 interface FileReaderScope {
 2   fun onFileOpen(): Unit
 3   fun onFileClosed(): Unit
 4   fun onLineRead(line: String): Unit
 5 }
 6 
 7 object Scope : FileReaderScope {
 8   override fun onFileOpen() = TODO()
 9   override fun onFileClosed() = TODO()
10   override fun onLineRead(line: String) = TODO()
11 }
12 
13 @Composable
14 fun FileReader(path: String, content: @Composable FileReaderScope.(path: String) -&gt; \
15 Unit) {
16   Column {
17     //...
18     Scope.content(path = path)
19   }
20 }
```
*NamedParamsOnFunctionTypes.kt*

Если убрать аннотацию `@Composable`, получим ошибку вида:

*«Named arguments are not allowed for function types.»*

Такое же требование подавляется для членов expect-классов. Jetpack Compose мультиплатформенный, поэтому рантайм должен принимать `expect`-функции и свойства с пометкой Composable.

## Проверка версии рантайма

Статические проверяющие и подавитель диагностики установлены. Дальше — проверка версии Compose runtime. Компилятор Compose требует минимальную версию рантайма и проверяет, что она не устарела. Обнаруживаются и отсутствие рантайма, и устаревшая версия.

Одна версия компилятора Compose может поддерживать несколько версий рантайма, если они не ниже минимальной.

Это вторая проверка версий: сначала компилятор Kotlin, затем Jetpack Compose runtime.

## Генерация кода

Наконец, компилятор переходит к фазе генерации кода. Это ещё одно общее с процессорами аннотаций — и те и другие часто синтезируют код для потребления рантайм-библиотеками.

## IR в Kotlin

Как сказано ранее, плагины компилятора могут не только генерировать код, но и изменять исходники — у них есть доступ к **промежуточному представлению** (IR) до получения итогового кода для целевых платформ. Плагин может подставлять и заменять параметры, добавлять новые, менять структуру кода до «фиксации». Это происходит на бэкенд-фазах компилятора Kotlin. Как можно догадаться, так Compose «внедряет» неявный дополнительный параметр `Composer` в каждый вызов Composable.

Плагины компилятора могут генерировать код в разных форматах. Для одной JVM можно было бы генерировать байткод, совместимый с Java, но с учётом планов команды Kotlin по стабилизации IR-бэкендов и сведению их к одному для всех платформ разумнее генерировать IR. IR — представление элементов языка **независимое от целевой платформы**. Генерация IR позволит сгенерированному коду Jetpack Compose быть мультиплатформенным.

Плагин компилятора Compose генерирует IR, регистрируя реализацию `IrGenerationExtension` — расширения общего IR-бэкенда компилятора Kotlin.

Для глубокого изучения Kotlin IR рекомендую [серию постов](https://blog.bnorm.dev/writing-your-second-compiler-plugin-part-2) Брайана Норманна про Kotlin IR и создание плагинов компилятора. Подробное изучение IR выходит за рамки этой книги.

## Lowering (понижение)

Термин «lowering» — перевод компилятором более высокоуровневых или продвинутых концепций в комбинацию более низкоуровневых атомарных. В Kotlin это обычная практика: есть промежуточное представление (IR), выражающее продвинутые концепции, которые затем переводятся в низкоуровневые атомы перед преобразованием в байткод JVM, JavaScript, IR LLVM и т.д. У компилятора Kotlin есть фаза lowering; её можно понимать как нормализацию.

Компилятор Compose должен понижать некоторые поддерживаемые библиотекой концепции до представления, понятного рантайму. Процесс lowering — фаза генерации кода для плагина компилятора Compose: обход элементов дерева IR и изменение IR в соответствии с потребностями рантайма.

Кратко о важных вещах в фазе lowering в этом разделе:

- Вывод стабильности классов и добавление метаданных для понимания в рантайме.
- Трансформация выражений live literals для доступа к экземпляру MutableState, чтобы рантайм мог отражать изменения в исходниках без перекомпиляции (live literals).
- Внедрение неявного параметра `Composer` во все Composable-функции и передача его во все вызовы Composable.
- Оборачивание тел Composable-функций для: генерации разных типов групп по управлению потоком (replaceable, movable и т.д.); поддержки аргументов по умолчанию в scope сгенерированной группы функции; обучения функции пропуску recomposition; распространения информации об изменении состояния вниз по дереву для автоматической recomposition при изменении.

Разберём виды lowering в плагине компилятора Jetpack Compose.

## Вывод стабильности класса

Умная recomposition означает пропуск recomposition Composable, когда их входы не изменились **и эти входы считаются стабильными**. Стабильность — важное понятие: рантайм Compose может безопасно читать и сравнивать эти входы для пропуска recomposition. Цель стабильности — помочь рантайму.

Напомним свойства стабильного типа:

- Вызовы `equals` для двух экземпляров всегда дают один и тот же результат для одних и тех же двух экземпляров — сравнение согласованно, рантайм может на него опереться.
- Composition всегда уведомляется при изменении публичного свойства типа. Иначе возможна рассинхронизация между входом Composable и актуальным состоянием при материализации. Чтобы этого не было, recomposition всегда запускается в таких случаях. **Умная recomposition не может опираться на такой вход.**
- Все публичные свойства — примитивы или типы, тоже считающиеся стабильными.

Все примитивные типы по умолчанию стабильны, а также `String` и все функциональные типы — они по определению неизменяемы. Неизменяемым типам не нужно уведомлять composition.

Мы также видели типы, которые не неизменяемы, но могут считаться стабильными — их можно пометить `@Stable`. Пример — `MutableState`: Compose уведомляется при каждом изменении, поэтому на него можно опираться для умной recomposition.

Для своих типов мы можем проверить выполнение перечисленных свойств и вручную пометить их как стабильные с помощью `@Immutable` или `@Stable`. Но полагаться на то, что разработчики будут соблюдать контракт, рискованно и сложно поддерживать. Желательно выводить стабильность класса автоматически.

Compose так и делает. Алгоритм вывода стабильности постоянно развивается; в общих чертах он обходит каждый класс и синтезирует для него аннотацию `@StabilityInferred`, а также синтетическое значение `static final int $stable`, кодирующее информацию о стабильности. Это значение поможет компилятору на следующих шагах генерировать код для определения стабильности класса в рантайме, чтобы Compose решал, нужно ли перезапускать зависящие от этого класса Composable-функции.

Не буквально каждый класс — только подходящие: публичные классы, не enum, не элемент enum, не интерфейс, не аннотация, не анонимный объект, не expect-элемент, не внутренний класс, не companion и не `inline`. И не те, что уже помечены как стабильные упомянутыми аннотациями. В итоге — обычные классы, data-классы и подобное, ещё не помеченные как стабильные. Это то, чем мы моделируем входы Composable-функций.

При выводе стабильности Compose учитывает разное. Тип считается стабильным, когда все поля класса только для чтения и стабильны (под «полем» — в смысле результирующего JVM-байткода). Классы вроде `class Foo` или `class Foo(val value: Int)` выводятся как стабильные (нет полей или только стабильные). Класс `class Foo(var value: Int)` сразу выводится как нестабильный.

На стабильность класса могут влиять параметры типа, например:

```kotlin
1 class Foo&lt;T&gt;(val value: T)
```
*FooWithTypeParams.kt*

В этом случае `T` используется в параметре класса, и стабильность `Foo` зависит от стабильности типа, подставленного вместо `T`. Так как `T` не reified, до рантайма он неизвестен. Нужен механизм определения стабильности класса в рантайме, когда тип для `T` станет известен. Компилятор Compose вычисляет и помещает в аннотацию `StabilityInferred` битовую маску, указывающую, что стабильность этого класса в рантайме должна зависеть от стабильности соответствующего параметра типа.

Наличие generic-типов не обязательно означает нестабильность. Компилятор знает, что код вроде `class Foo<T>(val a: Int, b: T) { val c: Int = b.hashCode() }` стабилен, так как hashCode по контракту всегда возвращает один и тот же результат для одного экземпляра.

Для классов, составленных из других классов, например `class Foo(val bar: Bar, val bazz: Bazz)`, стабильность выводится как комбинация стабильности всех аргументов, рекурсивно.

Внутреннее мутабельное состояние тоже делает класс нестабильным. Пример:

```kotlin
1 class Counter {
2  private var count: Int = 0
3  fun getCount(): Int = count
4  fun increment() { count++ }
5 }
```
*Counter.kt*

Состояние меняется со временем, даже если мутируется внутри самого класса. Рантайм не может полагаться на его согласованность.

В общем компилятор Compose считает тип стабильным только когда может это доказать. Например, интерфейс считается нестабильным — Compose не знает, как он будет реализован.

```kotlin
1 @Composable
2 fun &lt;T&gt; MyListOfItems(items: List&lt;T&gt;) {
3   // ...
4 }
```
*MyListOfItems.kt*

Здесь аргумент — `List`, который может быть реализован мутабельно (например, `ArrayList`). Компилятору небезопасно предполагать только неизменяемые реализации, и вывести это непросто, поэтому тип считается нестабильным.

Другой пример — типы с мутабельными публичными свойствами, чья реализация может быть неизменяемой. Они тоже по умолчанию считаются нестабильными — компилятор не может вывести такую тонкость.

Это минус: часто такие вещи могут быть реализованы неизменяемо, и для Compose runtime этого было бы достаточно. Поэтому если модель, используемая как вход Composable, считается Compose нестабильной, мы можем явно пометить её `@Stable`, если у нас есть информация и мы контролируем тип. В официальной документации приведён такой пример:

```kotlin
1 // Marking the type as stable to favor skipping and smart recompositions.
2 @Stable
3 interface UiState&lt;T : Result&lt;T&gt;&gt; {
4     val value: T?
5     val exception: Throwable?
6 
7     val hasError: Boolean
8         get() = exception != null
9 }
```
*UiState.kt*

Алгоритм вывода стабильности покрывает ещё случаи. По всем деталям рекомендую [тесты библиотеки](https://cs.android.com/androidx/platform/frameworks/support/+/androidx-main:compose/compiler/compiler-hosted/integration-tests/src/test/java/androidx/compose/compiler/plugins/kotlin/ClassStabilityTransformTests.kt) для `ClassStabilityTransform`.

Внутренние детали вывода стабильности могут со временем меняться и улучшаться. Для пользователей библиотеки это остаётся прозрачным.

## Включение live literals

**Оговорка:** этот раздел близок к деталям реализации и постоянно развивается; в будущем может не раз измениться.

Один из флагов компилятора — live literals. Было две реализации этой возможности, включаемые флагами `liveLiterals` (v1) или `liveLiteralsEnabled` (v2).

Live literals — возможность отражать изменения в превью Compose в реальном времени без перекомпиляции. Компилятор Compose заменяет такие выражения версиями, читающими значения из `MutableState`. Рантайм получает уведомления об изменениях сразу, без пересборки проекта. Как сказано в kdoc библиотеки:

*«Эта трансформация предназначена для улучшения опыта разработчика и не должна включаться в release-сборках — она заметно замедлит чувствительный к производительности код.»*

Компилятор Compose генерирует уникальные id для каждого константного выражения в коде, затем превращает эти константы в геттеры свойств, читающие из некоего `MutableState`, хранящегося в сгенерированном singleton-классе на файл. В рантайме есть API для получения значения этих констант по сгенерированному ключу.

Пример из kdoc библиотеки. Исходный Composable:

```kotlin
1 @Composable
2 fun Foo() {
3   print(&quot;Hello World&quot;)
4 }
```
*LiveLiterals1.kt*

преобразуется в:

```kotlin
 1 // file: Foo.kt
 2 @Composable
 3 fun Foo() {
 4     print(LiveLiterals$FooKt.`getString$arg-0$call-print$fun-Foo`())
 5 }
 6 
 7 object LiveLiterals$FooKt {
 8     var `String$arg-0$call-print$fun-Foo`: String = &quot;Hello World&quot;
 9     var `State$String$arg-0$call-print$fun-Foo`: MutableState&lt;String&gt;? = null
10     fun `getString$arg-0$call-print$fun-Foo`(): String {
11         
12         val field = this.`String$arg-0$call-print$fun-Foo`
13         
14         val state = if (field == null) {
15             val tmp = liveLiteral(
16                 &quot;String$arg-0$call-print$fun-Foo&quot;,
17                 this.`String$arg-0$call-print$fun-Foo`
18             )
19             this.`String$arg-0$call-print$fun-Foo` = tmp
20             tmp
21         } else field
22         
23         return field.value
24     }
25 }
```
*LiveLiterals2.kt*

Константа заменена геттером, читающим из `MutableState` в сгенерированном singleton для файла.

## Мемоизация лямбд Compose

На этом шаге генерируется IR, чтобы научить рантайм оптимизировать выполнение лямбд, передаваемых в Composable-функции. Это делается для двух видов лямбд:

- **Не-Composable лямбды:** компилятор генерирует IR для их мемоизации, оборачивая каждую лямбду в вызов `remember`. Например, колбэк, передаваемый в Composable. Здесь `remember` позволяет использовать slot table для хранения и последующего чтения этих лямбд.
- **Composable лямбды:** компилятор генерирует IR для оборачивания и добавления информации, чтобы научить рантайм хранить и читать выражение в/из Composition. Цель та же, что у `remember`, но без его использования. Пример — content Composable лямбды, передаваемые в узлы Compose UI при их вызове.

### Не-Composable лямбды

Этот шаг оптимизирует передаваемые в Composable лямбды для переиспользования. Kotlin уже оптимизирует лямбды без захвата значений, представляя их синглтонами — один экземпляр на всю программу. Но при захвате значений оптимизация невозможна: значения могут различаться при каждом вызове, нужен отдельный экземпляр. Compose умнее в этом случае. Пример:

```kotlin
1 @Composable
2 fun NamePlate(name: String, onClick: () -&gt; Unit) {
3   // ...
4   // onClick()
5   // ...
6 }
```
*NamePlateClickLambda.kt*

Здесь `onClick` — обычная Kotlin-лямбда, передаваемая в Composable. Если лямбда с места вызова захватывает значения, Compose может научить рантайм мемоизировать её — по сути обернув в вызов `remember`. Это делается через сгенерированный IR. Вызов будет запоминать лямбду по захваченным значениям **при условии, что эти значения стабильны**. Рантайм сможет переиспользовать существующие лямбды вместо создания новых, если захваченные значения совпадают (включая параметры).

Требование стабильности захваченных значений нужно потому, что они используются как аргументы-условия для `remember` и должны быть надёжны для сравнения.

Мемоизированные лямбды **не могут быть inline** — после подстановки в вызывающий код при компиляции запоминать уже нечего.

Оптимизация имеет смысл только для лямбд с захватом; без захвата достаточно оптимизации Kotlin (синглтоны).

Мемоизация делается по захваченным значениям лямбды. При генерации IR компилятор добавляет перед выражением вызов `remember` с типом возврата, совпадающим с типом мемоизированного выражения, затем generic-аргумент типа вызова (`remember<T>...`), затем все захваченные значения как аргументы-условия (`remember<T>(arg1, arg2...)`) для сравнения и наконец саму лямбду (`remember<T>(arg1, arg2..., expression)` как trailing lambda).

Использование захваченных значений как аргументов-условий гарантирует, что они служат ключами для запоминания результата выражения — он будет инвалидироваться при их изменении.

**Автоматическое запоминание** лямбд, передаваемых в Composable, даёт переиспользование при recomposition.

### Composable-лямбды

Компилятор Compose также умеет мемоизировать Composable-лямбды. Детали реализации для этого случая другие из-за «особой» реализации Composable-лямбд, но цель та же: хранить и читать эти лямбды в/из slot table.

Пример Composable-лямбды, которая будет мемоизирована:

```kotlin
1 @Composable
2 fun Container(content: @Composable () -&gt; Unit) {
3   // ...
4   // content()
5   // ...
6 }
```
*Container.kt*

Для этого IR лямбды изменяется так, чтобы сначала вызывать **composable factory function** с определёнными параметрами: `composableLambda(...)`.

Первым добавляется текущий `$composer` и передаётся: `composableLambda($composer, ...)`.

Затем параметр `key` — комбинация `hashcode` полностью квалифицированного имени Composable-лямбды и **смещения начала выражения** в файле для уникальности ключа (позиционная мемоизация): `composableLambda($composer, $key, ...)`.

После ключа добавляется булев параметр `shouldBeTracked` — нужно ли отслеживать этот вызов Composable-лямбды. Когда у лямбд нет захватов, Kotlin превращает их в синглтоны, они не меняются и не требуют отслеживания Compose: `composableLambda($composer, $key, $shouldBeTracked, ...)`.

Опционально может добавляться параметр арности выражения — только при более чем 22 параметрах: `composableLambda($composer, $key, $shouldBeTracked, $arity, ...)`.

В конце в обёртку передаётся сама лямбда (trailing lambda): `composableLambda($composer, $key, $shouldBeTracked, $arity, expression)`.

Назначение Composable factory function — **добавить replaceable group в composition для хранения выражения лямбды по сгенерированному ключу**. Так Compose сообщает рантайму, как хранить и извлекать Composable-выражение.

Помимо оборачивания Compose может оптимизировать Composable-лямбды без захвата значений так же, как Kotlin — представляя их синглтонами. Для этого генерируется синтетический `internal object` «ComposableSingletons» на каждый файл с Composable-лямбдами. Объект хранит (мемоизирует) статические ссылки на эти лямбды и геттеры для их получения.

У Composable-лямбд есть ещё одна оптимизация за счёт реализации: аналогично `MutableState`, лямбду вида `@Composable (A, B) -> C` можно считать реализованной как `State<@Composable (A, B) -> C`. Места вызова лямбды (`lambda(a, b)`) можно заменить на `lambda.value.invoke(a, b)`.

Это оптимизация: создаётся snapshotted state для всех Composable-лямбд, что позволяет Compose умнее перезапускать поддеревья при изменении лямбд. Изначально это называли «donut-hole skipping»: лямбда может обновляться «высоко» в дереве, а Compose перезапускает только «низкую» часть, где значение реально читается. Для лямбд это выгодный компромисс: по природе экземпляр передаётся вниз по иерархии и часто «читается» (вызывается) только в нижней части.

## Внедрение Composer

На этом шаге компилятор Compose заменяет все Composable-функции новыми версиями с добавленным синтетическим параметром `Composer`. Этот параметр также передаётся в каждый вызов Composable в коде, чтобы он был доступен в любой точке дерева, включая вызовы Composable-лямбд.

Требуется и переназначение типов: тип функции меняется при добавлении плагином дополнительных параметров.

![](resources/implicit_composer.png)
*Внедрение Composer*

Так `Composer` становится доступен для любого поддерева и несёт всю информацию для материализации composable-дерева и его обновления.

Пример:

```kotlin
 1 fun NamePlate(name: String, lastname: String, $composer: Composer) {
 2   $composer.start(123)
 3   Column(modifier = Modifier.padding(16.dp), $composer) {
 4     Text(
 5       text = name,
 6       $composer
 7     )
 8     Text(
 9       text = lastname,
10       style = MaterialTheme.typography.subtitle1,
11       $composer
12     )
13   }
14   $composer.end()
15 }
```
*NamePlate.kt*

Inline-лямбды без Composable намеренно не трансформируются — при компиляции они подставляются в вызывающий код и исчезают. Функции `expect` тоже не трансформируются — при разрешении типов они сводятся к `actual`, и трансформируются уже они.

## Распространение сравнения (comparison propagation)

Мы видели, как компилятор внедряет дополнительный параметр `$composer` и передаёт его во все вызовы Composable. Есть и другие метаданные, генерируемые и добавляемые к каждому Composable. Один из них — параметр `$changed`. Он передаёт информацию о том, могли ли входные параметры текущего Composable измениться с прошлой composition, и позволяет пропускать recomposition.

```kotlin
1 @Composable
2 fun Header(text: String, $composer: Composer&lt;*&gt;, $changed: Int)
```
*SyntheticChangedParam1.kt*

Параметр синтезируется как комбинация битов для **каждого** входного параметра функции (один параметр `$changed` кодирует условие для всех n входных параметров, порядка 10, в пределах числа бит; при большем числе параметров добавляются 2 или более флагов). Биты используются потому, что процессоры хорошо обрабатывают их.

Эта информация позволяет рантайму:

- Пропускать сравнения через `equals` для проверки изменения входного параметра относительно последнего сохранённого (из прошлых composition) в случаях, когда параметр известен как статический. Битовая маска `$changed` даёт эту информацию. Например, параметр — строковый литерал, константа и т.п. Биты флага сообщают рантайму, что значение **известно на этапе компиляции**, не изменится в рантайме, и рантайм может **никогда его не сравнивать**.
- В других случаях параметр **всегда** либо не менялся с прошлой composition, либо при изменении сравнение уже гарантированно выполнено родительским Composable в дереве — пересчитывать не нужно. Состояние параметра считается «определённым».
- В остальных случаях состояние «неопределённое» — рантайм сравнивает через `equals` и сохраняет в slot table для последующего использования. Значение бита для этого случая — `0`, случай по умолчанию. При `$changed == 0` мы говорим рантайму делать всю работу (без сокращений).

Пример тела Composable после внедрения параметра `$changed` и логики для него:

```kotlin
 1 @Composable 
 2 fun Header(text: String, $composer: Composer&lt;*&gt;, $changed: Int) {
 3   var $dirty = $changed
 4   if ($changed and 0b0110 === 0) {
 5     $dirty = $dirty or if ($composer.changed(text)) 0b0010 else 0b0100
 6   }
 7   if ($dirty and 0b1011 xor 0b1010 !== 0 || !$composer.skipping) {
 8     f(text) // executes body
 9   } else {
10     $composer.skipToGroupEnd()
11   }
12 }
```
*SyntheticChangedParam2.kt*

Здесь манипуляции с битами; не вдаваясь в детали, видно использование локальной переменной `$dirty` — хранит, изменился ли параметр, по битовой маске `$changed` и при необходимости по значению из slot table. Если значение «грязное» (изменилось), выполняется тело функции (recomposition). Иначе Composable пропускает recomposition.

Так как recomposition может происходить часто, передача информации об эволюции входного состояния может сэкономить время и место. Параметры нередко проходят через много Composable, и Compose не хочет каждый раз хранить и сравнивать их — это занимает место в slot table.

Как наш Composable получает параметр `$changed` от вызывающего, так же он должен передавать вниз по дереву информацию о параметрах, которую знает. Это называется «распространением сравнения» (comparison propagation). Информация доступна в теле во время composition: если мы уже знаем, что вход изменился, статичен и т.д., мы можем передать это в параметр `$changed` дочернего Composable, который использует тот же параметр.

Параметр `changed` также кодирует, стабилен ли переданный аргумент или нет. Это позволяет функции с более широким типом (например, `List<T>`) пропускать recomposition, если параметр стабилен на основе переданного аргумента (например, выражение `listOf(1, 2)`).

Подробнее об этом — в [видео](https://www.youtube.com/watch?v=bg0R9-AUXQM&ab_channel=LelandRichardson) Лиланда Ричардсона про основы этого механизма и вывод стабильности.

## Параметры по умолчанию

Ещё один вид метаданных, добавляемых к каждой Composable на этапе компиляции — параметр/параметры `$default`.

Поддержка аргументов по умолчанию в Kotlin не подходит для аргументов Composable-функций: выражения по умолчанию нужно вычислять внутри scope (сгенерированной группы) функции. Compose даёт альтернативную реализацию разрешения аргументов по умолчанию.

Compose представляет аргументы по умолчанию параметром-битовой маской `$default`, сопоставляющим каждый индекс параметра с битом. Аналогично параметру/параметрам `$changed`. Один параметр `$default` на каждые n входных параметров со значениями по умолчанию. Маска указывает, передан ли параметр в месте вызова или нужно использовать выражение по умолчанию.

Пример из документации библиотеки — Composable до и после внедрения маски `$default` и кода для её чтения и подстановки значения по умолчанию:

```kotlin
 1 // Before compiler (sources)
 2 @Composable fun A(x: Int = 0) {
 3   f(x)
 4 }
 5 
 6 // After compiler
 7 @Composable fun A(x: Int, $changed: Int, $default: Int) {
 8   // ...
 9   val x = if ($default and 0b1 != 0) 0 else x
10   f(x)
11   // ...
12 }
```
*DefaultParam.kt*

Снова битовые операции: проверка маски `$default` для подстановки `0` или переданного значения `x`.

## Генерация групп управления потоком

Компилятор Compose также вставляет **группу** в тело каждой Composable-функции. Типы групп зависят от структур управления потоком в теле:

- Replaceable groups.
- Movable groups.
- Restartable groups.

Composable-функции в рантайме эмитируют группы; группы оборачивают информацию о текущем состоянии вызова Composable. Так Composition знает, как очищать записанные данные при замене группы (replaceable), перемещать данные с сохранением идентичности Composable (movable) или перезапускать функцию при recomposition (restartable).

В итоге рантайму нужно уметь обрабатывать управление потоком по информации, хранящейся в Composition в памяти.

Группы несут информацию о позиции вызова в исходниках. Они оборачивают span текста и имеют ключ, в котором одним из факторов служит позиция вызова. Это позволяет хранить группу и обеспечивает позиционную мемоизацию.

### Replaceable groups

Ранее мы описали, что тело Composable-лямбды автоматически оборачивается вызовом Composable factory function с параметрами `$composer`, сгенерированным `$key` и самой лямбдой. В коде эта factory выглядит так:

```kotlin
 1 fun composableLambda(
 2     composer: Composer,
 3     key: Int,
 4     tracked: Boolean,
 5     block: Any
 6 ): ComposableLambda {
 7     composer.startReplaceableGroup(key)
 8     val slot = composer.rememberedValue()
 9     val result = if (slot === Composer.Empty) {
10         val value = ComposableLambdaImpl(key, tracked)
11         composer.updateRememberedValue(value)
12         value
13     } else {
14         slot as ComposableLambdaImpl
15     }
16     result.update(block)
17     composer.endReplaceableGroup()
18     return result
19 }
```
*ReplaceableGroup.kt*

Эта factory вызывается для Composable-лямбд, например для content наших Composable-функций. Она сначала начинает replaceable group с ключом и в конце закрывает группу, оборачивая span в середине. Между start и end обновляет composition нужной информацией — в данном случае оборачиваемой лямбдой.

То же происходит и для других вызовов Composable. Пример трансформации кода обычной Composable-функции с пометкой non-restartable:

```kotlin
 1 // Before compiler (sources)
 2 @NonRestartableComposable
 3 @Composable
 4 fun Foo(x: Int) {
 5   Wat()
 6 
 7 // After compiler
 8 @NonRestartableComposable
 9 @Composable
10 fun Foo(x: Int, %composer: Composer?, %changed: Int) {
11   %composer.startReplaceableGroup(&lt;&gt;)
12   Wat(%composer, 0)
13   %composer.endReplaceableGroup()
14 }
```
*ReplaceableGroup2.kt*

Вызов Composable также эмитирует replaceable group для хранения в Composition. Группы образуют дерево; каждая группа может содержать любое число дочерних. Если вызов `Wat` тоже Composable, компилятор вставит для него группу.

Ранее мы использовали пример с двумя вызовами `Text` в ветках `if`/`else` — идентичность сохраняется и по позиции вызова, так что рантайм различает эти вызовы:

```kotlin
1 if (condition) {
2   Text(&quot;Hello&quot;)
3 } else {
4   Text(&quot;World&quot;)
5 }
```
*ConditionalTexts.kt*

Composable с такой условной логикой тоже эмитирует replaceable group, чтобы при переключении условия группу можно было заменить.

### Movable groups

Группы, которые можно переупорядочивать без потери идентичности. Сейчас они нужны только для тела вызовов `key`. Напомним пример из предыдущей главы:

```kotlin
 1 @Composable
 2 fun TalksScreen(talks: List&lt;Talk&gt;) {
 3   Column {
 4     for (talk in talks) {
 5       key(talk.id) { // Unique key
 6         Talk(talk)
 7       }
 8     }
 9   }
10 }
```
*MovableGroup.kt*

Оборачивание `Talk` в `key` даёт уникальную идентичность. При оборачивании Composable в `key` генерируется movable group для переупорядочивания вызовов без потери идентичности элементов.

Пример трансформации Composable с `key`:

```kotlin
 1 // Before compiler (sources)
 2 @Composable
 3 fun Test(value: Int) {
 4   key(value) {
 5     Wrapper {
 6       Leaf(&quot;Value ${&#39;$&#39;}value&quot;)
 7     }
 8   }
 9 }
10 
11 // After
12 @Composable
13 fun Test(value: Int, %composer: Composer?, %changed: Int) {
14   // ...
15   %composer.startMovableGroup(&lt;&gt;, value)
16   Wrapper(composableLambda(%composer, &lt;&gt;, true) { %composer: Composer?, %changed: In\
17 t -&gt;
18     Leaf(&quot;Value %value&quot;, %composer, 0)
19   }, %composer, 0b0110)
20   %composer.endMovableGroup()
21   // ...
22 }
```
*MovableGroup2.kt*

### Restartable groups

Restartable groups, вероятно, самые интересные. Они вставляются только для restartable Composable-функций. Они тоже оборачивают вызов Composable, но кроме того расширяют вызов `end`, чтобы он возвращал nullable-значение. Оно будет `null` только когда тело Composable не читает никакого изменяемого состояния — **recomposition не потребуется**. В таком случае не нужно сообщать рантайму, как перезапускать этот Composable. Иначе возвращается ненулевое значение, и компилятор генерирует лямбду, сообщающую рантайму, как «перезапустить» (выполнить заново) Composable и обновить Composition.

В коде это выглядит так:

```kotlin
 1 // Before compiler (sources)
 2 @Composable fun A(x: Int) {
 3   f(x)
 4 }
 5 
 6 // After compiler
 7 @Composable
 8 fun A(x: Int, $composer: Composer&lt;*&gt;, $changed: Int) {
 9   $composer.startRestartGroup()
10   // ...
11   f(x)
12   $composer.endRestartGroup()?.updateScope { next -&gt; 
13     A(x, next, $changed or 0b1) 
14   }
15 }
```
*RestartableGroup.kt*

Scope обновления для recomposition содержит новый вызов того же Composable.

Такой тип группы генерируется для всех Composable-функций, читающих состояние.

Из официальной документации — дополнительная логика компилятора для исполняемых блоков при генерации типов групп:

- Если блок выполняется ровно 1 раз всегда, группы не нужны.
- Если из набора блоков каждый раз выполняется ровно один (например, ветки if или when), вокруг каждого блока вставляется replaceable group. Это условная логика.
- Movable group нужна только для content-лямбды вызовов `key`.

## Klib и генерация decoy

В компилятор Compose добавлена поддержка `.klib` (мультиплатформа) и Kotlin/JS. Она нужна из-за десериализации IR зависимостей в JS — после трансформации IR сигнатуры типов перестают совпадать (Compose добавляет синтетические параметры к объявлениям и вызовам Composable-функций).

Поэтому в Kotlin/JS Compose не заменяет IR функций (как в JVM), а создаёт копии. Оригинальное объявление функции сохраняется для связи между функцией в метаданных Kotlin и её IR, ссылки в коде по-прежнему разрешаются, а IR копии изменяется Compose по необходимости. Чтобы различать их в рантайме, к имени добавляется суффикс `$composable`.

```kotlin
 1 // Before compiler (sources)
 2 @Composable
 3 fun Counter() {
 4   ...
 5 }
 6 
 7 // Transformed
 8 @Decoy(...)
 9 fun Counter() { // signature is kept the same
10   illegalDecoyCallException(&quot;Counter&quot;)
11 }
12 
13 @DecoyImplementation(...)
14 fun Counter$composable( // signature is changed
15     $composer: Composer,
16     $changed: Int
17 ) {
18   ...transformed code...
19 }
```
*KlibAndDecoys.kt*

Подробнее о поддержке `.klib` и Kotlin/JS — в [посте Андрея Шикова](https://dev.to/shikasd/kotlin-compiler-plugins-and-binaries-on-multiplatform-139e).
